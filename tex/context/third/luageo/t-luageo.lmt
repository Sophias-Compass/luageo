if not  s then modules = { } end modules ['luageo'] = {
    version   = 1.000,
    comment   = "mp-geo rewrite",
    author    = "Gavin Polhemus",
    copyright = "Gavin Polhemus",
    license   = "see context related readme files"
}

local tonumber = tonumber
local cosd, sind, sqrt = math.cosd, math.sind, math.sqrt
local gmatch = string.gmatch

--
-- Load all of the data from the data files, converting latitude, longitude pairs to 3D points.
--

-- Set the data files' location.

moduledata     = moduledata or { }
local geo      = { }
moduledata.geo = geo

geo.datafolder = "data/"

-- Create the tables that will hold 3D boundary points for countries and islands.

local countries = { }
local islands   = { }

-- Define functions needed to convert the data into 3D boundary points.

do

    -- Convert latitude and longitude (in minutes) to 3D point on the unit sphere.
  
    local function latlonto3D(la,lo)
        local lat = la/60
        local lon = lo/60
        local clat = cosd(lat)
        return {
            x = clat*cosd(lon),
            y = clat*sind(lon),
            z = sind(lat)
        }
    end
    
    -- LPeg parses the data in the files

    local lpegmatch = lpeg.match

    local lparent    = lpeg.P("(")
    local rparent    = lpeg.P(")")
    local comma      = lpeg.P(",")
    local whitespace = lpeg.patterns.whitespace
    local restofline = (1-whitespace)^0
    local comment    = lpeg.P("%") * restofline
    local pair       = lparent
                     * ((1-comma  )^1/tonumber)
                     * comma
                     * ((1-rparent)^1/tonumber)
                     * rparent

    local p =
        comment^0  * whitespace^0
      * restofline * whitespace^0
      * lpeg.Ct (
            (
                pair/latlonto3D * whitespace^0
              + comment         * whitespace^0
            )^1
        )
    
    -- Functions used in the data files deliver parse and convert the data

    function moduledata.geo.addcountry(d)
        local name = geo.datafolder .. (d.file or "default.dat")
        local data = io.loaddata(name)
        if data and #data > 0 then
            local boundaries = lpegmatch(p,data)
            countries[#countries+1] = {
                boundary3D = boundaries,
                color      = d.color
            }
        end
    end

    function moduledata.geo.addisland(d)
        local b = d.boundary
        if b and #b > 0 then
            for i=1,#b do
                local bi = b[i]
                b[i] = latlonto3D(bi[1],bi[2])
            end
            islands[#islands+1] = {
                boundary3D = b,
                color      = d.color,
            }
        end
    end

end

-- Read the data files to produce the countries and islands tables.
-- Caching is actually slower unless we byte compile.

statistics.starttiming(geo)

dofile("data/iles.lua")
dofile("data/ameriquenord.lua")
dofile("data/caraibes.lua")
dofile("data/ameriquecentrale.lua")
dofile("data/ameriquesud.lua")
dofile("data/europe.lua")
dofile("data/asia.lua")
dofile("data/afrique.lua")

statistics.stoptiming(geo)

print(statistics.elapsedseconds(geo))


--
-- Convert 3D points to a specific 2D projection
--

-- Funtion to rotate the 3D points before projection

local cLat, sLat, cLon, sLon

local function rotate(p3D)
    local p3DxcLon = p3D.x*cLon
    local p3DxsLon = p3D.x*sLon
    local p3DycLon = p3D.y*cLon
    local p3DysLon = p3D.y*sLon
    local p3DysLonplusp3DxcLon = p3DysLon + p3DxcLon
    return
        (p3DysLonplusp3DxcLon)*cLat + p3D.z*sLat,
        p3DycLon - p3DxsLon,
        -(p3DysLonplusp3DxcLon)*sLat + p3D.z*cLat
end

-- Project a boundary from 3D to 2D, only the visible part, closing along the horizon, and add it to the compound path for MetaPost.

local function appendpath(area,step)
    local boundary = area.boundary3D
    local path = { }
    for i=1,#boundary,step do
        -- Rotate the point area.boundary3D to new coordinates x, y, z.
        local x, y, z = rotate(boundary[i])
        -- If the point is on our side of the horizon, then add it to path.
        if x > 0 then
            path[#path+1] = { y, z }
        end
    end
    -- ensure that the last point matches the first point
    if #path > 2 and path[#path] ~= path[1] then
        path[#path+1] = path[1]
    end
    -- For paths that have at least three distinct points...
    if #path > 3 then
        for i=1,#path do
            local p = path[i]
            local q = path[i+1] or path[1]
            -- Vector from q to p.
            local Y1 = p[1] - q[1]
            local Y2 = p[2] - q[2]
            local Ysqr = Y1^2 + Y2^2
            if Ysqr > 0.01 then
                -- Vector bisecting angle pOq.
                local X1 = p[1] + q[1]
                local X2 = p[2] + q[2]
                -- The magnitude of X used in computing coefficients
                local magX = sqrt(X1^2 + X2^2)
                -- Coefficients for X and Y are not obvious!
                local C = 4/(3*magX) - 1/6
                local D = (1 - magX/6) / (2 + magX)
                -- Won't need the basis vectors again, so just scale them.
                X1 = C * X1
                X2 = C * X2
                Y1 = D * Y1
                Y2 = D * Y2
                -- Add control point for departure from p
                p[5] = X1 + Y1
                p[6] = X2 + Y2
                -- Add control point for approach to q
                q[3] = X1 - Y1
                q[4] = X2 - Y2
            end
        end
        -- Add "cycle" to the end of the path so it can be filled.
	    path[#path+1] = "cycle"
--         inspect(path)
        return {
            path   = path,
            append = true
        }
    end
end

-- The MetaPost functions that return the projected compound path

if MP then

    function MP.globe(Lat,Lon)
        cLat = cosd(Lat)
        sLat = sind(Lat)
        cLon = cosd(Lon)
        sLon = sind(Lon)
        --
        local path = { }
        local step = 1
        for i=1, #countries do
            local p = appendpath(countries[i],step)
            if p then
                path[#path+1] = p
            end
        end
        for i=1, #islands do
            local p = appendpath(islands[i],step)
            if p then
                path[#path+1] = p
            end
        end
        mp.inject.path(path)
        --
        cLat = 0
        sLat = 0
        cLon = 0
        sLon = 0
    end

    function MP.globetrot(Lat,Lon,step)
        cLat = cosd(Lat)
        sLat = sind(Lat)
        cLon = cosd(Lon)
        sLon = sind(Lon)
        --
        local path = { }
        for i=1, #countries do
            local p = appendpath(countries[i],step)
            if p then
                path[#path+1] = p
            end
        end
        for i=1, #islands do
            local p = appendpath(islands[i],step)
            if p then
                path[#path+1] = p
            end
        end
        mp.inject.path(path)
        --
        cLat = 0
        sLat = 0
        cLon = 0
        sLon = 0
    end

end
