if not  s then modules = { } end modules ['luageo'] = {
    version   = 1.000,
    comment   = "mp-geo rewrite",
    author    = "Gavin Polhemus",
    copyright = "Gavin Polhemus",
    license   = "see context related readme files"
}

local tonumber = tonumber
local cosd, sind, sqrt = math.cosd, math.sind, math.sqrt
local gmatch = string.gmatch

--
-- Load all of the data from the data files, converting latitude, longitude pairs to 3D points.
--

-- Set the data files' location.

moduledata     = moduledata or { }
local geo      = { }
moduledata.geo = geo

geo.datafolder = "data/"

-- Create the tables that will hold 3D boundary points for countries and islands.

local countries = { }
local islands   = { }

-- Define functions needed to convert the data into 3D boundary points.

do

    -- Convert latitude and longitude (in minutes) to 3D point on the unit sphere.
  
    local function latlonto3D(la,lo)
        local lat = la/60
        local lon = lo/60
        local clat = cosd(lat)
        return {
            x = clat*cosd(lon),
            y = clat*sind(lon),
            z = sind(lat)
        }
    end
    
    -- LPeg parses the data in the files

    local lpegmatch = lpeg.match

    local lparent    = lpeg.P("(")
    local rparent    = lpeg.P(")")
    local comma      = lpeg.P(",")
    local whitespace = lpeg.patterns.whitespace
    local restofline = (1-whitespace)^0
    local comment    = lpeg.P("%") * restofline
    local pair       = lparent
                     * ((1-comma  )^1/tonumber)
                     * comma
                     * ((1-rparent)^1/tonumber)
                     * rparent

    local p =
        comment^0  * whitespace^0
      * restofline * whitespace^0
      * lpeg.Ct (
            (
                pair/latlonto3D * whitespace^0
              + comment         * whitespace^0
            )^1
        )
    
    -- Functions used in the data files deliver parse and convert the data

    function moduledata.geo.addcountry(d)
        local name = geo.datafolder .. (d.file or "default.dat")
        local data = io.loaddata(name)
        if data and #data > 0 then
            local boundaries = lpegmatch(p,data)
            countries[#countries+1] = {
                boundary3D = boundaries,
                color      = d.color
            }
        end
    end

    function moduledata.geo.addisland(d)
        local b = d.boundary
        if b and #b > 0 then
            for i=1,#b do
                local bi = b[i]
                b[i] = latlonto3D(bi[1],bi[2])
            end
            islands[#islands+1] = {
                boundary3D = b,
                color      = d.color,
            }
        end
    end

end

-- Read the data files to produce the countries and islands tables.
-- Caching is actually slower unless we byte compile.

statistics.starttiming(geo)

dofile("data/iles.lua")
dofile("data/ameriquenord.lua")
dofile("data/caraibes.lua")
dofile("data/ameriquecentrale.lua")
dofile("data/ameriquesud.lua")
dofile("data/europe.lua")
dofile("data/asia.lua")
dofile("data/afrique.lua")

statistics.stoptiming(geo)

print(statistics.elapsedseconds(geo))


--
-- Convert 3D points to a specific 2D projection
--

-- Funtion to rotate the 3D points before projection

local cLat, sLat, cLon, sLon

local function rotate(p3D)
    local p3DxcLon = p3D.x*cLon
    local p3DxsLon = p3D.x*sLon
    local p3DycLon = p3D.y*cLon
    local p3DysLon = p3D.y*sLon
    local p3DysLonplusp3DxcLon = p3DysLon + p3DxcLon
    return
        (p3DysLonplusp3DxcLon)*cLat + p3D.z*sLat,
        p3DycLon - p3DxsLon,
        -(p3DysLonplusp3DxcLon)*sLat + p3D.z*cLat
end

-- Close the cut from p to q with an arc (actually a cubic bezier, unfortunately).

local function closecut(p,q)
    -- Basis vector bisecting angle pOq.
    local X1 = p[1] + q[1]
    local X2 = p[2] + q[2]
    -- Orthogonal basis vector in plane pOq.
    local Y1 = p[1] - q[1]
    local Y2 = p[2] - q[2]
    -- The magnitude of X used in computing coefficients
    local magX = sqrt(X1^2 + X2^2)
    -- Coefficients for X and Y are not obvious!
    local C = 4/(3*magX) - 1/6
    local D = (1 - magX/6) / (2 + magX)
    -- Won't need the basis vectors again, so just scale them.
    X1 = C * X1
    X2 = C * X2
    Y1 = D * Y1
    Y2 = D * Y2
    -- Add control point for departure from p
    p[5] = X1 + Y1
    p[6] = X2 + Y2
    -- Add control point for approach to q
    q[3] = X1 - Y1
    q[4] = X2 - Y2
end

-- Project a boundary from 3D to 2D, only the visible part, closing along the horizon, and add it to the compound path for MetaPost.

local function appendpath(area,step)
    local boundary = area.boundary3D
    local path = { }
    local n = 0
    local cut = false
    local visible = false
    local cutendtostart = false
    local last = nil
    local prev = nil
    for i=1,#boundary,step do
        prev = last
         -- Rotate the point area.boundary3D to new coordinates view={x, y, z}.
        local x, y, z = rotate(boundary[i])
        -- If the point is on our side of the horizon, then it is added.
        if x > 0 then
            -- Project 3D view points to 2D path pairs and add to path
            last = { y, z }
            n = n + 1 ; path[n] = last
            if cut and visible then -- If the path is visible and currently being cut...
                closecut(prev,last) -- add control points to previous point and current point...
                cut = false         -- and stop cutting.
            end
            -- Any visible point means the area is visible.
            visible = true
        elseif visible then
            -- If the point is over the horizon, then it is not added and we note that this is a horizon cut.
            cut = true
        else
            -- We don't need to cut an area that isn't visible.
            cutendtostart = true
        end
    end
    if visible and n > 1 then
        -- A visible path needs to be closed and added to the fullglobepath list.
        if cut or cutendtostart then
            -- If we are in the middle of a cut, or if the path started with a cut...
            -- add control points to this point and first point.
            closecut(last,path[1])
        end
        -- Add "cycle" to the end of the path so it can be filled.
        n = n + 1 ; path[n] = "cycle"
        -- Clean up so this stuff isn't added to fullglobepath.
--         inspect(path)
        return {
            path   = path,
            append = true
        }
    end
end

-- The MetaPost functions that return the projected compound path

if MP then

    function MP.globe(Lat,Lon)
        cLat = cosd(Lat)
        sLat = sind(Lat)
        cLon = cosd(Lon)
        sLon = sind(Lon)
        --
        local path = { }
        local step = 1
        for i=1, #countries do
            local p = appendpath(countries[i],step)
            if p then
                path[#path+1] = p
            end
        end
        for i=1, #islands do
            local p = appendpath(islands[i],step)
            if p then
                path[#path+1] = p
            end
        end
        mp.inject.path(path)
        --
        cLat = 0
        sLat = 0
        cLon = 0
        sLon = 0
    end

    function MP.globetrot(Lat,Lon,step)
        cLat = cosd(Lat)
        sLat = sind(Lat)
        cLon = cosd(Lon)
        sLon = sind(Lon)
        --
        local path = { }
        for i=1, #countries do
            local p = appendpath(countries[i],step)
            if p then
                path[#path+1] = p
            end
        end
        for i=1, #islands do
            local p = appendpath(islands[i],step)
            if p then
                path[#path+1] = p
            end
        end
        mp.inject.path(path)
        --
        cLat = 0
        sLat = 0
        cLon = 0
        sLon = 0
    end

end
