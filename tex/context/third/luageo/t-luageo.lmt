if not  s then modules = { } end modules ['luageo'] = {
    version   = 1.000,
    comment   = "mp-geo rewrite",
    author    = "Gavin Polhemus",
    copyright = "Gavin Polhemus",
    license   = "see context related readme files"
}

local tonumber = tonumber
local cosd, sind, sqrt = math.cosd, math.sind, math.sqrt
local gmatch = string.gmatch

-- Load all of the data from the data files, converting latitude, longitude pairs to 3D points.

moduledata     = moduledata or { }
local geo      = { }
moduledata.geo = geo

geo.datafolder = "data/"

-- Takes a latitude, longitude pair (in MINUTES) and returns a 3D point on a unit sphere.

local cLat, sLat, cLon, sLon

-- Close the cut from p to q with an arc (actually a cubic bezier, unfortunately).

local function closecut(p,q) -- we can inline the helpers
    -- Basis vector bisecting angle pOq.
    local X1 = p[1] + q[1]
    local X2 = p[2] + q[2]
    -- Orthogonal basis vector in plane pOq.
    local Y1 = p[1] - q[1]
    local Y2 = p[2] - q[2]
    -- The magnitude of X used in computing coefficients
    local magX = sqrt(X1^2 + X2^2)
    -- Coefficients for X and Y are not obvious!
    local C = 4/(3*magX) - 1/6
    local D = (1 - magX/6) / (2 + magX)
    -- Won't need the basis vectors again, so just scale them.
    X1 = C * X1
    X2 = C * X2
    Y1 = D * Y1
    Y2 = D * Y2
--     -- Add control point for departure from p
--     p[5] = X1 + Y1
--     p[6] = X2 + Y2
--     -- Add control point for approach to q
--     q[3] = X1 - Y1
--     q[4] = X2 - Y2
end

local function rotate(p3D)
    local p3DxcLon = p3D.x*cLon
    local p3DxsLon = p3D.x*sLon
    local p3DycLon = p3D.y*cLon
    local p3DysLon = p3D.y*sLon
    local p3DysLonplusp3DxcLon = p3DysLon + p3DxcLon
    return
        (p3DysLonplusp3DxcLon)*cLat + p3D.z*sLat,
        p3DycLon - p3DxsLon,
        -(p3DysLonplusp3DxcLon)*sLat + p3D.z*cLat
end

-- better do something data/Cameriquenord.dat: -
--
--   return {
--     {
--         file = "mexique.dat",
--         color = "violet",
--     },
--     {
--         color = "orange",
--         file = "usa1.dat",
--     },
--     {
--         file = "usa2.dat",
--         color = "orange",
--     },
--     {
--         file = "canada.dat",
--         color = "jaune",
--     }
-- }

--  country table

local countries = { }
local islands   = { }

-- Reads continent data to make countries list with color = "color" and file = "file".

-- { color = "red", file = "name" }

do

    local function latlonto3D(la,lo)
        local lat = la/60
        local lon = lo/60
        local clat = cosd(lat)
        return {
            x = clat*cosd(lon),
            y = clat*sind(lon),
            z = sind(lat)
        }
    end

    local lpegmatch = lpeg.match

    local lparent    = lpeg.P("(")
    local rparent    = lpeg.P(")")
    local comma      = lpeg.P(",")
    local whitespace = lpeg.patterns.whitespace
    local restofline = (1-whitespace)^0
    local comment    = lpeg.P("%") * restofline
    local pair       = lparent
                     * ((1-comma  )^1/tonumber)
                     * comma
                     * ((1-rparent)^1/tonumber)
                     * rparent

    local p =
        comment^0  * whitespace^0
      * restofline * whitespace^0
      * lpeg.Ct (
            (
                pair/latlonto3D * whitespace^0
              + comment         * whitespace^0
            )^1
        )

    function moduledata.geo.addcountry(d)
        local name = geo.datafolder .. (d.file or "default.dat")
        local data = io.loaddata(name)
        if data and #data > 0 then
            local boundaries = lpegmatch(p,data)
            countries[#countries+1] = {
                boundary3D = boundaries,
                color      = d.color
            }
        end
    end

    function moduledata.geo.addisland(d)
        local b = d.boundary
        if b and #b > 0 then
            for i=1,#b do
                local bi = b[i]
                b[i] = latlonto3D(bi[1],bi[2])
            end
            islands[#islands+1] = {
                boundary3D = b,
                color      = d.color,
            }
        end
    end

end


-- These functions are called each time a globe is made.

-- Lua makes the globe and returns the disconnected path

-- Make a path for the area and add it to the fullglobepath list.

local function appendpath(area,step)
    local boundary = area.boundary3D
    local path = { }
    local n = 0
    local cut = false
    local visible = false
    local cutendtostart = false
    local last = nil
    local prev = nil
    for i=1,#boundary,step do
        prev = last
         -- Rotate the point area.boundary3D to new coordinates view={x, y, z}.
--         local view = rotate(boundary[i])
        local x, y, z = rotate(boundary[i])
        -- If the point is on our side of the horizon, then it is added.
--         if view.x > 0 then
        if x > 0 then
            -- Project 3D view points to 2D path pairs and add to path
--             last = { view.y, view.z }
            last = { y, z }
            n = n + 1 ; path[n] = last
            if cut and visible then -- If the path is visible and currently being cut...
                closecut(prev,last) -- add control points to previous point and current point...
                cut = false         -- and stop cutting.
            end
            -- Any visible point means the area is visible.
            visible = true
        elseif visible then
            -- If the point is over the horizon, then it is not added and we note that this is a horizon cut.
            cut = true
        else
            -- We don't need to cut an area that isn't visible.
            cutendtostart = true
        end
    end
    if visible and n > 1 then
        -- A visible path needs to be closed and added to the fullglobepath list.
        if cut or cutendtostart then
            -- If we are in the middle of a cut, or if the path started with a cut...
            -- add control points to this point and first point.
            closecut(last,path[1])
        end
        -- Add "cycle" to the end of the path so it can be filled.
        n = n + 1 ; path[n] = "cycle"
        -- Clean up so this stuff isn't added to fullglobepath.
--         inspect(path)
        return {
            path   = path,
            append = true
        }
    end
end

-- caching is actually slower unless we byte compile

statistics.starttiming(geo)

dofile("data/iles.lua")
dofile("data/ameriquenord.lua")
dofile("data/caraibes.lua")
dofile("data/ameriquecentrale.lua")
dofile("data/ameriquesud.lua")
dofile("data/europe.lua")
dofile("data/asia.lua")
dofile("data/afrique.lua")

statistics.stoptiming(geo)

print(statistics.elapsedseconds(geo))
-- os.exit()

if MP then

    function MP.globe(Lat,Lon)
        cLat = cosd(Lat)
        sLat = sind(Lat)
        cLon = cosd(Lon)
        sLon = sind(Lon)
        --
        local path = { }
        local step = 1
        for i=1, #countries do
            local p = appendpath(countries[i],step)
            if p then
                path[#path+1] = p
            end
        end
        for i=1, #islands do
            local p = appendpath(islands[i],step)
            if p then
                path[#path+1] = p
            end
        end
        mp.inject.path(path)
        --
        cLat = 0
        sLat = 0
        cLon = 0
        sLon = 0
    end

    function MP.globetrot(Lat,Lon,step)
        cLat = cosd(Lat)
        sLat = sind(Lat)
        cLon = cosd(Lon)
        sLon = sind(Lon)
        --
        local path = { }
        for i=1, #countries do
            local p = appendpath(countries[i],step)
            if p then
                path[#path+1] = p
            end
        end
        for i=1, #islands do
            local p = appendpath(islands[i],step)
            if p then
                path[#path+1] = p
            end
        end
        mp.inject.path(path)
        --
        cLat = 0
        sLat = 0
        cLon = 0
        sLon = 0
    end

end
